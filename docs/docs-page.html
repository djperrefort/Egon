<!DOCTYPE html>
<html lang="en">

<head>
    <title>Egon Framework</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Egon Framework">
    <meta name="author" content="MWV Research Group">
    <link rel="shortcut icon" href="assets/images/logo.svg">

    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">

    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/github.min.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
</head>

<body class="docs-page">
    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible mr-2 d-xl-none" type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo"><a class="navbar-brand" href="index.html">
                        <img class="logo-icon mr-2" src="assets/images/logo.svg" alt="">
                        <span class="logo-text">Egon</span>
                    </a></div>
                </div><!--//docs-logo-wrapper-->

                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <!-- Right aligned header content should go here -->
                </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->

    <div class="docs-wrapper">
        <div id="docs-sidebar" class="docs-sidebar">
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-introduction"><span class="theme-icon-holder mr-2"><i class="fas fa-book"></i></span>Introduction</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-install">Installation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-how-it-works">How It Works</a></li>
                    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-building-pipelines"><span class="theme-icon-holder mr-2"><i class="fas fa-tools"></i></span>Building a Pipeline</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-source-nodes">Source Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-target-nodes">Target Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-generic-nodes">Generic Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-pipeline-assembly">Pipeline Assembly</a></li>
                    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-function-decorators"><span class="theme-icon-holder mr-2"><i class="fas fa-at"></i></span>Function Decorators</a></li>
                    <!-- <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-pipeline-visualization"><span class="theme-icon-holder mr-2"><i class="fas fa-map-signs"></i></span>Pipeline Visualization</a></li> -->
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-validation"><span class="theme-icon-holder mr-2"><i class="fas fa-check-circle"></i></span>Pipeline Validation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-node-validation">Node Validation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-pipeline-validation">Pipeline Validation</a></li>
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-mock"><span class="theme-icon-holder mr-2"><i class="fas fa-tasks"></i></span>Unit Testing</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-mock-source">MockSource</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-mock-target">MockTarget</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-testing-example">Testing Example</a></li>
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-FAQ"><span class="theme-icon-holder mr-2"><i class="fas fa-question-circle"></i></span>FAQ</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-general-questions">General Questions</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-parallel-processing">Parallel Processing</a></li>
                </ul>
            </nav><!--//docs-nav-->

        </div><!--//docs-sidebar-->

        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="section-introduction">
                    <header class="docs-header">
                        <h1 class="docs-heading">Introduction</h1>
                        <p>
                            Egon is a lightweight framework for building data analysis pipelines in Python.
                            Egon puts your analysis code first, making it easy to implement parallelized workflows without having to deal with the added overhead of message brokers or task managers.
                            Some of the benefits of the Egon framework are that it:
                        </p>
                        <ol>
                            <li>Integrates easily with existing projects, including test suites and continuous-integration tasks.</li>
                            <li>Includes automatic pipeline validation to reduce development/implementation errors and improve pipeline stability.</li>
                            <li>Encourages modular design principles that help you build maintainable code that is easy to test and deploy.</li>
                            <!-- <li>Makes pipeline visualization a breeze using built-in pipeline visualization tools.</li> -->
                        </ol>
                    </header><!--//docs-header-->

                    <section class="docs-intro" id="item-install">
                        <h2 class="section-heading">Installation</h2>
                        <p>
                            Egon is open-source and free to use (although attribution is both appreciated and encouraged where appropriate).
                            You can install the <code>egon</code> package using pip:
                        </p>
                        <pre class="shadow-lg rounded"><code class="bash">
pip install egon
						</code></pre>
                        <p>Alternatively, the package source code can be downloaded from
                            <a class="theme-link" href="https://github.com/Egon-Framework/Egon">GitHub.com</a> using your favorite command line utility:
                        </p>
                        <pre class="shadow-lg rounded"><code class="bash">
git clone egon
cd egon
python setup.py install --user
						</code></pre>
                    </section><!--//section-->

                    <section class="docs-section" id="item-how-it-works">
                        <h2 class="section-heading">How it Works</h2>
                        <p>
                            Egon works by breaking down your analysis into discrete, reusable units.
                            Those units can then be tested individual before being assembled and deployed as a single coherent pipeline.
                            Consider for a moment the classic example of an ETL pipeline:
                        </p>
                        <img class="figure-img img-fluid rounded" src="assets/images/etl.svg" alt="" style="width: 60%;">
                        <p>
                            The pipeline shown above consists of three discrete steps, each of which are connected in a particular order.
                            When building with Egon, this structure is represented as a collection of interconnected
                            <code>Node</code> objects:
                        </p>
                        <img class="figure-img img-fluid rounded" src="assets/images/annotated_etl.svg" alt="" style="width: 100%;">
                        <p>
                            <code>Node</code> objects can be connected in any order and are designed to run asynchronously.
                            This means you can scale your analysis by allocating additional processes to each node.
                            Nodes are also smart enough to automatically exit once they are no longer needed, freeing up resources on the host machine once they are no longer needed.
                        </p>
                    </section><!--//section-->
                </article>

                <article class="docs-article" id="section-building-pipelines">
                    <header class="docs-header">
                        <h1 class="docs-heading">Building a Pipeline</h1>
                    </header><!--//docs-header-->

                    <section class="docs-intro">
                        <p>
                            The first step in building a pipeline is to define the necessary nodes.
                            Ideally, each node should reflect a single independent task.
                            When processing a fixed amount of information, nodes should also be able to shutdown automatically once there is no more data for them to process.
                            Let's continue from the ETL example shown above.
                        </p>
                    </section>

                    <div class="callout-block callout-block-info mr-1">
                        <div class="content">
                            <h4 class="callout-title">
	                                <span class="callout-icon-holder">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
                                Quick Tip
                            </h4>
                            <p>
                                The following sections demonstrate the construction of pipeline nodes as a dedicated class.
                                This is the most flexible way to build a node, but if you are looking for a shorter syntax check out the <a class="scrollto active" href="#section-function-decorators">Function Decorators</a> section.
                            </p>
                        </div><!--//content-->
                    </div>

                    <section class="docs-intro" id="item-source-nodes">
                        <h2 class="section-heading">Source Nodes</h2>
                        <p>
                            <code>Source</code> type nodes are special in that they have no incoming pipeline connections and can only produce data.
                            This makes them ideal for the <b>extract</b> task.
                        </p>
                        <p>
                            We build the extract node as a class that inherits from the <code>Source</code> class.
                            We add a single output connector and define the analysis logic of the node in the <code>action</code> method.
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Output
from egon.nodes import Source


# Nodes are represented as classes that inherit from the egon.nodes module
class Extract(Source):

    def __init__(self, num_processes=1):
        """The extract step of an ETL style pipeline"""

        # Here we define an output connector for the class
        # This allows the node to send data further down the pipeline
        # For more complicated nodes, you can define as many connectors as needed.
        self.data_output = Output()
        super().__init__(num_processes)

    def setup(self):
        """Setup tasks are optional and can be used to configure a pipeline node"""

        self.database = connect_to_database()

    def action(self):
        """Action tasks reflect the core analysis logic of a pipeline node"""

        # Once the iterator is exhausted this function will exit and the pipeline node will start to shutdown
        for data in self.database.get_fixed_number_of_items():
            self.data_output.put(data)

    def teardown(self):
        """Teardown tasks are optional and can be used for clean up tasks"""

        self.database.disconnect()
							</code></pre>

                    </section><!--//section-->

                    <section class="docs-section" id="item-target-nodes">
                        <h2 class="section-heading">Target Nodes</h2>
                        <p>
                            <code>Target</code> nodes are similar to <code>Source</code> nodes except they receive data instead of sending it.
                            This makes them ideal for the <b>load</b> task.

                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input
from egon.nodes import Target


class Load(Target):

    def __init__(self, num_processes=1):
        """The load step of an ETL style pipeline"""

        # Here we define an input connector for the class
        # This allows the node to receive data from other nodes
        self.data_input = Input()
        super().__init__(num_processes)

    # The rest of the class should include the same
    # ``setup``, ``action``, and ``teardown`` style structure from earlier.
    ...
                        </code></pre>

                        <p>
                            It's important that pipeline nodes exit gracefully once there is no more data to process.
                            Input connectors include the <code>iter_get</code> method which allows you to iterate over incoming data.
                            <code>iter_get</code> is smart enough to automatically exit once there are no longer any upstream processes left to feed it data.
                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input
from egon.nodes import Target


class Load(Target):

    def __init__(self, num_processes=1):
        """The load step of an ETL style pipeline"""

        self.data_input = Input()
        super().__init__(num_processes)

    def action(self):
        """Load data into a directory"""

        for data in self.data_input.iter_get():
            ...  # Logic to insert data into a target database goes here
                        </code></pre>

                    </section><!--//section-->

                    <section class="docs-section" id="item-generic-nodes">
                        <h2 class="section-heading">Generic Nodes</h2>

                        <p>
                            Generic <code>Node</code> objects can have both input and output connectors.
                            In principle we can define as many input or output connections as necessary.
                            However for the ETL example we only need one of each.
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input, Output
from egon.nodes import Node


class Transform(Node):

    def __init__(self, num_processes=1):
        """The transform step of an ETL style pipeline"""

        # ``Node`` subclasses can have an arbitrary number of input AND output connectors.
        # Here we define an input AND output connectors for the class
        # This allows the node to communicate with upstream and downstream nodes
        self.data_in = Input()
        self.data_out = Output()
        super().__init__(num_processes)


    # The rest of the class should include the same
    # ``setup``, ``action``, and ``teardown`` style structure from earlier.
    ...
                    </code></pre>
                    </section><!--//section-->

                    <section class="docs-section" id="item-pipeline-assembly">
                        <h2 class="section-heading">Pipeline Assembly</h2>
                        <p>
                            The last step in constructing a pipeline is to connect together the individual nodes.
                            Connectors provide a signal/slot style interface where input/output connectors can be connected together as follows:
                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.pipeline import Pipeline


class ETL(Pipeline):

    def __init__(self):

        # Define the nodes of the pipeline
        self.extract = Extract()
        self.transform = Transform(num_processes=4)  # Allocate multiple processes
        self.load = Load()

        # Limit the number of objects the input connector is allowed to store in memory
        # This will limit memory usage and force the ``extract`` node to wait
        # for the ``transform`` node to catch up if it falls behind.
        self.transform.data_in.maxsize = 100

        # Connect each of the nodes together
        self.extract.data_out.connect(self.transform.data_in)
        self.transform.data_out.connect(self.load.data_in)
        super().__init__()  # Super should be AFTER the pipeline node attributes have been defined
                        </code></pre>
                        <p>
                            The <code>validate</code> task handles process allocation and runs automated validation tasks (see the documentation below).
                            The entire pipeline can then be launched in one line:
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
etl_pipeline = ETL()
etl_pipeline.validate()
etl_pipeline.run()
                        </code></pre>

                        <div class="callout-block callout-block-info mr-1">
                            <div class="content">
                                <h4 class="callout-title">
	                                <span class="callout-icon-holder">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
                                    Quick Tip
                                </h4>
                                <p>
                                    In the above example each output connector is connected to a single input connector.
                                    In general, an output connector can only connect to a single output.
                                    However, multiple output connectors can connect to a single input.
                                    This allows you to consolidate data from multiple nodes into a single input.
                                </p>
                            </div><!--//content-->
                        </div>

                    </section><!--//section-->
                </article><!--//docs-article-->

                <article class="docs-article" id="section-function-decorators">
                    <header class="docs-header">
                        <h1 class="docs-heading">Function Decorators</h1>
                        <section class="docs-intro">
                            <p>
                                Egon provides function decorators that make it easy to cast existing logic as pipeline objects.
                                This allows you to quickly build pipeline nodes without having to define an entire class.
                                For example, a node designed to determine the sum of two numbers might look as follows:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_node

@as_node
def add_two_numbers(x, y):
    return x + y
						    </code></pre>

                            <div class="callout-block callout-block-info mr-1">
                                <div class="content">
                                    <h4 class="callout-title">
	                                <span class="callout-icon-holder">
		                                <i class="fas fa-info-circle"></i>
		                            </span><!--//icon-holder-->
                                        Quick Tip
                                    </h4>
                                    <p>
                                        Wrapped functions maintain the same docstring and signature as the original function.
                                        They can also be called in exactly the same manner as their unwrapped counterparts.
                                        This allows you to easily port existing logic into a pipeline structure without impacting the existing API design.
                                    </p>
                                </div><!--//content-->
                            </div>

                            <p>
                                Separate decorators exist for casting functions as different kinds of pipeline nodes.
                                They behave exactly the same as class based nodes, except they do not support setup or teardown tasks.
                                Here is an example of a pipeline for adding two numbers using function decorators:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_source, as_node, as_target
from egon.pipeline import Pipeline


@as_source
def generate_numbers():
    for i in range(100):
        yield i, i + 1


@as_node
def add(x, y):
    return x + y


@as_target
def print_sum(x):
    print(x)


class AddingPipeline(Pipeline):
    """A pipeline for generating and then adding numbers"""

    def __init__(self):
        # Define the nodes of the pipeline
        self.generate_numbers = generate_numbers
        self.add = add
        self.print_sum = print_sum

        # Nodes run on a single forked process by default.
        # Additional processes can be allocated for higher performance.
        self.add.num_processes = 4

        self.generate_numbers.output.connect(self.add.input)
        self.add.output.connect(self.print_sum.input)


pipeline = AddingPipeline()
pipeline.validate()
pipeline.run()
						    </code></pre>
                        </section><!--//docs-intro-->
                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <!--
                <article class="docs-article" id="section-pipeline-visualization">
                    <header class="docs-header">
                        <h1 class="docs-heading">Pipeline Visualization</h1>
                        <section class="docs-intro">
                            <div class="alert alert-danger" role="alert">
                                Pipeline visualization is not currently available in the public package release.
                                Stay tuned for official visualization support in upcoming package versions.
                            </div>
                        </section></!--//docs-intro--/>
                    </header></!--//docs-header--/>

                </article></!--//docs-article--/>
                -->

                <article class="docs-article" id="section-validation">
                    <header class="docs-header">
                        <h1 class="docs-heading">Pipeline Validation</h1>
                        <section class="docs-intro">
                            <p>
                                As the size and complexity of your pipeline grows, you'll want to be sure you don't leave any loose ends.
                                Nodes with unconnected inputs/outputs can leave you with a broken pipeline that consumes unnecessary resources.
                                Fortunately, <code>Egon</code> incorporates automated validation methods to help ensure you pipeline runs smoothly.
                            </p>
                        </section><!--//docs-intro-->

                        <section class="docs-section" id="item-node-validation">
                            <h2 class="section-heading">Node Validation</h2>
                            <p>
                                The <code>validation</code> method checks the interconnectivity of a node to its neighbors.
                                If a node has any input/output connectors that aren't connected to other nodes, an error will be raised.
                                The error will indicate both the problem and problematic connector.
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_source


@as_source
def generate_numbers():
    for i in range(100):
        yield i, i + 1

generate_numbers.validate()

# egon.exceptions.MissingConnectionError: Connector &lt;egon.connectors.Input(name=None) object at 0x7f408d078eb0> does not have an established connection (Node: &lt;WrappedSource(wrapped_function=generate_numbers) object at 0x7f408d078d90>)
						    </code></pre>
                            <p>
                                Individual node validation is a useful step to incorporate into a project test suite.
                            </p>
                        </section><!--//docs-intro-->

                        <section class="docs-section" id="item-pipeline-validation">
                            <h2 class="section-heading">Pipeline Validation</h2>
                            <p>
                                <code>Pipeline</code> objects also have a <code>validation</code> method.
                                The process of validating a pipeline is similar to validating a node, except it checks all nodes in the given pipeline.
                                Best practice is to validate a pipeline at least once before running it:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
my_pipeline = MyCustomPipeline()
my_pipeline.validate()
my_pipeline.run()
						    </code></pre>
                        </section><!--//docs-intro-->

                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <article class="docs-article" id="section-mock">
                <header class="docs-header">
                    <h1 class="docs-heading">Unit Testing</h1>
                    <p>

                        The object oriented design of pipeline nodes mean you test nodes individually before deploying them to a combined pipeline.
                        The <code>mock</code> module provides mockup pipeline nodes useful for the construction of unit-tests or as a placeholders in early development.
                        Mock nodes differ from the normal pipeline nodes described above in the following ways:
                    </p>
                    <ul>
                        <li>By default, mock nodes do not fork any processes and run entirely in the same process they were instantiated in.</li>
                        <li>Mock objects include predefined <code>action</code> methods so you don't need to write your own.</li>
                    </ul>

                    <div class="callout-block callout-block-danger mr-1">
                        <div class="content">
                            <h4 class="callout-title">
	                                <span class="callout-icon-holder">
		                                <i class="fas fa-exclamation-triangle"></i>
		                            </span><!--//icon-holder-->
                                Important
                            </h4>
                            <p>
                                When building your test suite, be sure to run your nodes in the main thread by setting <code>num_process=0</code> for each instantiated node.
                                This will ensure you don't end up with any annoying forked processes should you need to call the <code>execute</code> method during testing.
                            </p>
                        </div><!--//content-->
                    </div>

                </header><!--//docs-header-->

                <section class="docs-intro" id="item-mock-source">
                    <h2 class="section-heading">MockSource</h2>
                    <p>
                        <code>MockSource</code> objects allow you to easily load data into a connected, downstream node.
                        Any data stored in the <code>load_data</code> attribute will be sent to the <code>output</code> connector when the node executes.
                    </p>
                    <pre class="shadow-lg rounded"><code class="bash">
from egon.mock import MockSource

# You can define the data to load at instantiation
mock_source = MockSource(load_data=[1, 2, 3])

# You can also modify the list after instantiation
mock_source.load_data.append(4)

# Any objects you specify in ``load_data`` is sent to the ``output`` connector
mock_source.output.connect(my_node_to_test.input)

mock_source.execute()
my_node_to_test.execute()
						</code></pre>
                </section><!--//section-->

                <section class="docs-intro" id="item-mock-target">
                    <h2 class="section-heading">MockTarget</h2>
                    <p>
                        <code>MockTarget</code> objects act as accumulators.
                        When executed they collect any data passed to their <code>input</code> connector attribute into a list.
                    </p>
                    <pre class="shadow-lg rounded"><code class="bash">
from egon.mock import MockTarget

# Once executed, the mock target will accumulate any data sent to it's input connector
mock_target = MockTarget()
my_node_to_test.output.connect(mock_target.input)

my_node_to_test.execute()
mock_target.execute()

# The mock target will store data in the ``accumulated_data`` list
first_value = mock_target.accumulated_data[0]
						</code></pre>
                </section><!--//section-->

                <section class="docs-intro" id="item-testing-example">
                    <h2 class="section-heading">Testing Example</h2>
                    <p>
                        Using the <code>unittest</code> testing framework, we outline an example test below.
                    </p>
                    <pre class="shadow-lg rounded"><code class="bash">
from unittest import TestCase

from egon.mock import MockSource, MockTarget


class MyTestClass(TestCase):

    def setUp(self) -> None:
        """Define and setup the nodes used in the test suite"""

        # Create the nodes to be used in testing
        self.source = MockSource()
        self.node = MyCustomNode(num_processes=0)
        self.success_target = MockTarget()
        self.failure_target = MockTarget()

        # Connect the nodes
        self.source.output.connect(self.node.input)
        self.node.success_output.connect(self.simulation_target.input)
        self.node.failure_output.connect(self.failure_target.input)

        # Run the nodes
        for node in (self.source, self.node, self.simulation_target, self.failure_target):
            node.execute()
                    </code></pre>
                </section><!--//section-->

            </article>

                <article class="docs-article" id="section-FAQ">
                    <header class="docs-header">
                        <h1 class="docs-heading">FAQ</h1>
                        <p>
                            Answers to some commonly asked questions are listed below.
                        </p>
                        <section class="docs-section">
                            <h2 class="section-heading" id="item-general-questions">General Questions</h2>
                            <h5><i class="fas fa-question-circle"></i> I have a question or found a bug not mentioned in the docs. What should I do?</h5>
                            <p>
                                If you have an unanswered question, or you are facing some other issue with the <code>egon</code> package, please raise an issue on <a class="theme-link" href="https://github.com/djperrefort/Egon/issues">GitHub</a>.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> What is the preferred method of attribution?</h5>
                            <p>Project attributions and acknowledgments are greatly appreciated.</p>
                            <p>Please cite the following (version independent) Zenodo DOI in published works:
                                <a href="https://doi.org/10.5281/zenodo.4396074"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.4396074.svg" alt="DOI" style="all: unset;"></a>
                            </p>
                            <h5><i class="fas fa-question-circle"></i> What License is Egon released under?</h5>
                            <p>
                                Egon is open source under the GNU General Public License version 3.0.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Who built Egon?</h5>
                            <p>
                                Egon was built by the MWV Research Group at the University of Pittsburgh.
                                It was designed to support ongoing astrophysical research by providing a uniform framework for deploying analysis pipelines to supercomputing centers.
                            </p>
                        </section>
                        <section class="docs-section">
                            <h2 class="section-heading" id="item-parallel-processing">Parallel Processing</h2>
                            <h5><i class="fas fa-question-circle"></i> Does Egon support distributed computing?</h5>
                            <p>
                                Egon is designed to be a lightweight parallelization wrapper.
                                In alignment with this design goal, deployment to distributed systems is not currently supported.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Can I dynamically change the number of allocated processes during runtime?</h5>
                            <p>
                                The number of processes assigned to a given node can be changed at any point after instantiation.
                                However, the number of processes cannot be changed while the node is running.
                                If any of the forked processes assigned to a node are currently running, you must wait for them to exit.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Help, my pipeline wont exit!</h5>
                            <p>
                                Start by making sure you have connected all of your nodes together in the right order.
                                Also make sure no errors are raised when you call the <code>validate</code> method of your pipeline.
                                If these two things check out, you likely have one or more nodes that are still expecting input data but haven't received it yet.
                            </p>
                            <p>
                                If you believe your problem may have been caused by an issue with the <code>Egon</code> package itself, please raise an issue on <a class="theme-link" href="https://github.com/djperrefort/Egon/issues">GitHub</a>.
                            </p>
                        </section><!--//docs-intro-->
                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <footer class="footer">
                    <div class="container text-center py-5">
                        <small class="copyright">Built by the MWV Research Group<a href="https://zenodo.org/badge/latestdoi/323648779"></a></small>
                        <br>
                        <a href="https://doi.org/10.5281/zenodo.4396074"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.4396074.svg" alt="DOI" style="all: unset;"></a>
                    </div>
                </footer>
            </div>
        </div>
    </div><!--//docs-wrapper-->

    <!-- Javascript -->
    <script src="assets/plugins/jquery-3.4.1.min.js"></script>
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script>
    <script src="assets/plugins/jquery.scrollTo.min.js"></script>
    <script src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script>
    <script src="assets/js/docs.js"></script>

</body>

</html> 

