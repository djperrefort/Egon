<!DOCTYPE html>
<html lang="en">

<head>
    <title>Egon Framework</title>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="description" content="Egon Framework">
    <meta name="author" content="MWV Research Group">
    <link rel="shortcut icon" href="assets/images/logo.svg">

    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">

    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/github.min.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
</head>

<body class="docs-page">
    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible mr-2 d-xl-none" type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo"><a class="navbar-brand" href="index.html">
                        <img class="logo-icon mr-2" src="assets/images/logo.svg" alt="">
                        <span class="logo-text">Egon</span>
                    </a></div>
                </div><!--//docs-logo-wrapper-->

                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <!-- Right aligned header content should go here -->
                </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->

    <div class="docs-wrapper">
        <div id="docs-sidebar" class="docs-sidebar">
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-introduction"><span class="theme-icon-holder mr-2"><i class="fas fa-book"></i></span>Introduction</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-install">Installation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-how-it-works">How It Works</a></li>
                    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-building-pipelines"><span class="theme-icon-holder mr-2"><i class="fas fa-tools"></i></span>Building a Pipeline</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-source-nodes">Source Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-target-nodes">Target Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-generic-nodes">Generic Nodes</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-pipeline-assembly">Pipeline Assembly</a></li>
                    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-function-decorators"><span class="theme-icon-holder mr-2"><i class="fas fa-at"></i></span>Function Decorators</a></li>
                    <!-- <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-pipeline-visualization"><span class="theme-icon-holder mr-2"><i class="fas fa-map-signs"></i></span>Pipeline Visualization</a></li> -->
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-validation"><span class="theme-icon-holder mr-2"><i class="fas fa-check-circle"></i></span>Pipeline Validation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-node-validation">Node Validation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-pipeline-validation">Pipeline Validation</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-connector-errors">Connector Errors</a></li>
                    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-FAQ"><span class="theme-icon-holder mr-2"><i class="fas fa-question-circle"></i></span>FAQ</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-general-questions">General Questions</a></li>
                    <li class="nav-item"><a class="nav-link scrollto" href="#item-parallel-processing">Parallel Processing</a></li>
                </ul>
            </nav><!--//docs-nav-->

        </div><!--//docs-sidebar-->

        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="section-introduction">
                    <header class="docs-header">
                        <h1 class="docs-heading">Introduction</h1>
                        <p>
                            Egon is a lightweight framework for building data analysis pipelines in Python.
                            Egon puts your analysis code first, making it easy to implement parallelized workflows without having to deal with the added overhead of message brokers or task managers.
                            Some of the benefits of the Egon framework are that it:
                        </p>
                        <ol>
                            <li>Integrates easily with existing projects, including test suites and continuous-integration tasks.</li>
                            <li>Includes automatic pipeline validation to reduce development/implementation errors and improve pipeline stability.</li>
                            <li>Encourages modular design principles that help you build maintainable code that is easy to test and deploy.</li>
                            <!-- <li>Makes pipeline visualization a breeze using built-in pipeline visualization tools.</li> -->
                        </ol>
                    </header><!--//docs-header-->

                    <section class="docs-intro" id="item-install">
                        <h2 class="section-heading">Installation</h2>
                        <p>
                            Egon is open-source and free to use (although attribution is both appreciated and encouraged where appropriate).
                            You can install the Python Egon Framework using pip:
                        </p>
                        <pre class="shadow-lg rounded"><code class="bash">
pip install egon
						</code></pre>
                        <p>Alternatively, the package source code can be downloaded from
                            <a class="theme-link" href="https://github.com/Egon-Framework/Egon">GitHub.com</a> using your favorite command line utility:
                        </p>
                        <pre class="shadow-lg rounded"><code class="bash">
git clone egon
cd egon
python setup.py install --user
						</code></pre>
                    </section><!--//section-->

                    <section class="docs-section" id="item-how-it-works">
                        <h2 class="section-heading">How it Works</h2>
                        <p>
                            Egon works by breaking down your analysis into discrete, reusable units.
                            Those units can then be assembled, tested, and deployed as a single a coherent pipeline.
                            Consider for a moment the classic example of an ETL pipeline:
                        </p>
                        <img class="figure-img img-fluid rounded" src="assets/images/etl.svg" alt="" style="width: 60%;">
                        <p>
                            The pipeline shown above consists of three discrete steps, each of which are connected in a particular order.
                            When building with Egon, this structure is represented as a collection of interconnected
                            <code>Node</code> objects:
                        </p>
                        <img class="figure-img img-fluid rounded" src="assets/images/annotated_etl.svg" alt="" style="width: 100%;">
                        <p>
                            <code>Node</code> objects can be connected in any order and are designed to run asynchronously.
                            This means you can scale your analysis by allocating additional processes to each node.
                            Nodes are also smart enough to automatically exit once they are no longer needed.
                        </p>
                    </section><!--//section-->
                </article>

                <article class="docs-article" id="section-building-pipelines">
                    <header class="docs-header">
                        <h1 class="docs-heading">Building a Pipeline</h1>
                    </header><!--//docs-header-->

                    <section class="docs-intro">
                        <p>
                            The first step in building a pipeline is to define the necessary nodes.
                            Ideally, each node should reflect a single independent task.
                            When processing a fixed amount of information, nodes should also be able to shutdown automatically once there is no more data for them to process.
                        </p>
                        <p>
                            Let's continue from the ETL example shown above.
                        </p>
                    </section>

                    <div class="alert alert-primary" role="alert">
                        The following sections demonstrate the construction of pipeline nodes as a dedicated class.
                        This is the most flexible way to build a node, but if you are looking for a shorter syntax check out the <a class="scrollto active" href="#section-function-decorators">function Decorators</a> section.
                    </div>

                    <section class="docs-intro" id="item-source-nodes">
                        <h2 class="section-heading">Source Nodes</h2>
                        <p>
                            <code>Source</code> type nodes are special in that they have no incoming pipeline connections and can only produce data.
                            This makes them ideal for the <b>extract</b> task.

                        </p>
                        <p>
                            We build the extract node as a class that inherits from the <code>Source</code> class.
                            We add a single output connector and define the analysis logic of the node in the <code>action</code> method.
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Output
from egon.nodes import Source


# Nodes are represented as classes that inherit from the egon.nodes module
class Extract(Source):

    # Here we define an output connector for the class
    # This allows the node to send data further down the pipeline
    # For more complicated nodes, you can define as many connectors as needed.
    data_output = Output()

    def setup(self):
        """Setup tasks are optional and can be used to configure a pipeline node"""

        self.database = connect_to_database()

    def action(self):
        """Action tasks reflect the core analysis logic of a pipeline node"""

        # Once the iterator is exhausted this function will exit and the pipeline node will start to shutdown
        for data in self.database.get_fixed_number_of_items():
            self.data_output.put(data)

    def teardown(self):
        """Teardown tasks are optional and can be used for clean up tasks"""

        self.database.disconnect()
							</code></pre>

                    </section><!--//section-->

                    <section class="docs-section" id="item-target-nodes">
                        <h2 class="section-heading">Target Nodes</h2>
                        <p>
                            <code>Target</code> nodes are similar to <code>Source</code> nodes except they receive data instead of sending it.
                            This makes them ideal for the <b>load</b> task.

                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input
from egon.nodes import Target


class Load(Target):

    # Here we define an input connector for the class
    # This allows the node to receive data from other nodes
    data_input = Input()

    # The rest of the class should include the same
    # ``setup``, ``action``, and ``teardown`` structure from earlier.
    ...
                        </code></pre>

                        <p>
                            It's important that pipeline nodes exit gracefully once there is no more data to process.
                            Input connectors include the <code>iter_get</code> method which allows you to iterate over incoming data.
                            <code>iter_get</code> is smart enough to automatically exit once there are no longer any upstream processes left to feed it data.
                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input
from egon.nodes import Target


class Load(Target):
    data_input = Input()

    def action(self):
        """Load data into a directory"""

        for data in self.data_input.iter_get():
            ...  # Logic to insert data into a target database goes here
                        </code></pre>

                    </section><!--//section-->

                    <section class="docs-section" id="item-generic-nodes">
                        <h2 class="section-heading">Generic Nodes</h2>

                        <p>
                            Generic <code>Node</code> objects can have both input and output connectors.
                            In principle we can define as many input or output connections as necessary.
                            However for the ETL example we only need one of each.
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input, Output
from egon.nodes import Node


class Transform(Node):

    # ``Node`` subclasses can have an arbitrary number of input AND output connectors.
    # Here we define an input AND output connectors for the class
    # This allows the node to communicate with upstream and downstream nodes
    data_in = Input()
    data_out = Output()

    # The rest of the class should include the same
    # ``setup``, ``action``, and ``teardown`` structure from earlier.
    ...
                    </code></pre>
                    </section><!--//section-->

                    <section class="docs-section" id="item-pipeline-assembly">
                        <h2 class="section-heading">Pipeline Assembly</h2>
                        <p>
                            The last step in constructing a pipeline is to connect together the individual nodes.
                            Connectors provide a signal/slot style interface where input/output connectors can be connected together as follows:
                        </p>
                        <pre class="shadow-lg rounded"><code class="python">
from egon.pipeline import Pipeline


class ETL(Pipeline):

    def __init__(self):

        # Define the nodes of the pipeline
        self.extract = Extract()
        self.transform = Transform(num_processes=4)  # Allocate multiple processes
        self.load = Load()

        # Connect each of the nodes together
        self.extract.data_out.connect(self.transform.data_in)
        self.transform.data_out.connect(self.load.data_in)
                        </code></pre>
                        <p>
                            The <code>validate</code> task handles process allocation and runs automated validation tasks (see the documentation below).
                            The entire pipeline can then be launched in one line:
                        </p>

                        <pre class="shadow-lg rounded"><code class="python">
etl_pipeline = ETL()
etl_pipeline.validate()
etl_pipeline.run()
                        </code></pre>
                    </section><!--//section-->
                </article><!--//docs-article-->

                <article class="docs-article" id="section-function-decorators">
                    <header class="docs-header">
                        <h1 class="docs-heading">Function Decorators</h1>
                        <section class="docs-intro">
                            <p>
                                Egon provides function decorators that make it easy to cast existing logic as pipeline objects.
                                This allows you to quickly build pipeline nodes without having to define an entire class.
                                For example, a node designed to determine the sum of two numbers might look as follows:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_node

@as_node
def add_two_numbers(x, y):
    return x + y
						    </code></pre>
                            <div class="alert alert-primary" role="alert">
                                Wrapped functions maintain the same docstring and signature as the original function.
                                They can also be called in exactly the same manner as their unwrapped counterparts.
                                This allows you to easily port existing logic into a pipeline structure without impacting the existing API design.
                            </div>
                            <p>
                                Separate decorators exist for casting functions as different kinds of pipeline nodes.
                                They behave exactly the same as class based nodes, except they do not support setup or teardown tasks.
                                Here is an example of a pipeline for adding two numbers using function decorators:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_source, as_node, as_target
from egon.pipeline import Pipeline


@as_source
def generate_numbers():
    for i in range(100):
        yield i, i + 1


@as_node
def add(x, y):
    return x + y


@as_target
def print_sum(x):
    print(x)


class AddingPipeline(Pipeline):
    """A pipeline for generating and then adding numbers"""

    def __init__(self):
        # Define the nodes of the pipeline
        self.generate_numbers = generate_numbers
        self.add = add
        self.print_sum = print_sum

        self.generate_numbers.output.connect(self.add.input)
        self.add.output.connect(self.print_sum.input)


pipeline = AddingPipeline()
pipeline.validate()
pipeline.run()
						    </code></pre>
                        </section><!--//docs-intro-->
                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <!--
                <article class="docs-article" id="section-pipeline-visualization">
                    <header class="docs-header">
                        <h1 class="docs-heading">Pipeline Visualization</h1>
                        <section class="docs-intro">
                            <div class="alert alert-danger" role="alert">
                                Pipeline visualization is not currently available in the public package release.
                                Stay tuned for official visualization support in upcoming package versions.
                            </div>
                        </section></!--//docs-intro--/>
                    </header></!--//docs-header--/>

                </article></!--//docs-article--/>
                -->

                <article class="docs-article" id="section-validation">
                    <header class="docs-header">
                        <h1 class="docs-heading">Pipeline Validation</h1>
                        <section class="docs-intro">
                            <p>
                                As the size and complexity of your pipeline grows, you'll want to be sure you don't leave any loose ends.
                                Nodes with unconnected inputs/outputs can leave you with a broken pipeline that consumes unnecessary resources.
                                Fortunately, <code>Egon</code> incorporates automated validation methods to help ensure you pipeline runs smoothly.
                            </p>
                        </section><!--//docs-intro-->

                        <section class="docs-section" id="item-node-validation">
                            <h2 class="section-heading">Node Validation</h2>
                            <p>
                                The <code>validation</code> method checks the interconnectivity of a node to its neighbors.
                                If a node has any input/output connectors that aren't connected to other nodes, an error will be raised.
                                The error will indicate both the problem and problematic connector.
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.decorators import as_source


@as_source
def generate_numbers():
    for i in range(100):
        yield i, i + 1

generate_numbers.validate()

# egon.exceptions.MissingConnectionError: Connector &lt;egon.connectors.Input(name=None) object at 0x7f408d078eb0> does not have an established connection (Node: &lt;WrappedSource(wrapped_function=generate_numbers) object at 0x7f408d078d90>)
						    </code></pre>
                            <p>
                                Individual node validation is a useful step to incorporate into a project test suite.
                            </p>
                        </section><!--//docs-intro-->

                        <section class="docs-section" id="item-pipeline-validation">
                            <h2 class="section-heading">Pipeline Validation</h2>
                            <p>
                                <code>Pipeline</code> objects also have a <code>validation</code> method.
                                The process of validating a pipeline is similar to validating a node, except it checks all nodes in the given pipeline.
                                Best practice is to validate a pipeline at least once before running it:
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
my_pipeline = MyCustomPipeline()
my_pipeline.validate()
my_pipeline.run()
						    </code></pre>
                        </section><!--//docs-intro-->

                        <section class="docs-section" id="item-connector-errors">
                            <h2 class="section-heading">Connector Errors</h2>
                            <p>
                                Data should only ever flow through a pipeline in one direction.
                                <code>Egon</code> enforces this principle through a signal/slot style design.
                                To prevent against circular data flow, input connectors can only ever connect to output connectors (and visa/versa).
                            </p>
                            <pre class="shadow-lg rounded"><code class="python">
from egon.connectors import Input

input_1 = Input()
input_2 = Input()
input_1.connect(input_2)

# Raises: ValueError: Cannot join together two connection objects of the same type.
						    </code></pre>
                        </section><!--//docs-intro-->
                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <article class="docs-article" id="section-FAQ">
                    <header class="docs-header">
                        <h1 class="docs-heading">FAQ</h1>
                        <p>
                            Answers to some commonly asked questions are listed below.
                        </p>
                        <section class="docs-section">
                            <h2 class="section-heading" id="item-general-questions">General Questions</h2>
                            <h5><i class="fas fa-question-circle"></i> I have a question or found a bug not mentioned in the docs. What should I do?</h5>
                            <p>
                                If you have an unanswered question, or you are facing some other issue with the <code>Egon</code> package, please raise an issue on <a class="theme-link" href="https://github.com/djperrefort/Egon/issues">GitHub</a>.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> What is the preferred method of attribution?</h5>
                            <p>
                                Project attributions and acknowledgments are greatly appreciated.
                                Please cite the following Zenodo DOI in published works.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> What License is Egon released under?</h5>
                            <p>
                                Egon is open source under the GNU General Public License version 3.0.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Who built Egon?</h5>
                            <p>
                                Egon was built by the MWV Research Group at the University of Pittsburgh.
                                It was designed to support ongoing astrophysical research by providing a uniform framework for deploying analysis pipelines to supercomputing centers..
                            </p>
                        </section>
                        <section class="docs-section">
                            <h2 class="section-heading" id="item-parallel-processing">Parallel Processing</h2>
                            <h5><i class="fas fa-question-circle"></i> Does Egon support distributed computing?</h5>
                            <p>
                                Egon is designed to be a lightweight parallelization wrapper.
                                In alignment with this design goal deployment to distributed systems is not currently supported.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Can I dynamically change the number of allocated processes during runtime?</h5>
                            <p>
                                The number of processes assigned to a given node can be changed at any point after instantiation.
                                However, the number of processes cannot be changed while the node is running.
                                If any of the forked processes assigned to a node are currently running, you must wait for them to exit.
                            </p>
                            <h5><i class="fas fa-question-circle"></i> Help, my pipeline wont exit!</h5>
                            <p>
                                Start by making sure you have connected all of your nodes together in the right order.
                                Also make sure no errors are raised when you call the <code>validate</code> method of your pipeline.
                                If these two things check out, you likely have one or more nodes that are still expecting input data but haven't received it yet.
                            </p>
                            <p>
                                If you believe your problem may have been caused by an issue with the <code>Egon</code> package itself, please raise an issue on <a class="theme-link" href="https://github.com/djperrefort/Egon/issues">GitHub</a>.
                            </p>
                        </section><!--//docs-intro-->
                    </header><!--//docs-header-->

                </article><!--//docs-article-->

                <footer class="footer">
                    <div class="container text-center py-5">
                        <small class="copyright">Built by the MWV Research Group</small>
                    </div>
                </footer>
            </div>
        </div>
    </div><!--//docs-wrapper-->

    <!-- Javascript -->
    <script src="assets/plugins/jquery-3.4.1.min.js"></script>
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script>
    <script src="assets/plugins/jquery.scrollTo.min.js"></script>
    <script src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script>
    <script src="assets/js/docs.js"></script>

</body>

</html> 

